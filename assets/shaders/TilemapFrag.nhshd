#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require

layout(push_constant) uniform block
{
	vec2 eye;
    uint width;
    uint height;
};

layout (set = 0, binding = 0) readonly buffer legend
{
    uint16_t textureIndices[];
};

layout (set = 0, binding = 1) readonly buffer tilemap
{
    uint8_t tiles[];
};

layout (set = 1, binding = 10) uniform sampler2D globalTextures[];

layout (location = 0) out vec4 fragColor;

const uint INVALID_TEXTURE_INDEX = 255;

const float tileSize = 100.0;

void main()
{
    vec2 position = vec2(gl_FragCoord.x - eye.x, gl_FragCoord.y + eye.y);
    vec2 tilePos = position / tileSize;

    uint index = uint(tilePos.x) + uint(tilePos.y) * width;

    if(position.x < 0 || position.y < 0 || index >= height * width) { discard; }

    uint8_t tileType = tiles[index];

    if(tileType == INVALID_TEXTURE_INDEX) { discard; }

    uint16_t textureIndex = textureIndices[tileType];

    vec2 texcoord = mod(tilePos, 1.0);

    fragColor = texture(globalTextures[textureIndex], texcoord);

    if(texcoord.x < 0.01 || texcoord.y < 0.01) { fragColor = vec4(1.0, 0.0, 0.0, 1.0); }
}