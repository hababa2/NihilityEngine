#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require

#define DEBUG 0

layout(push_constant) uniform block
{
	vec2 eye;
    vec2 tileSize;
    uint width;
    uint height;
};

layout (set = 0, binding = 0) readonly buffer legend
{
    uint16_t textureIndices[];
};

layout (set = 0, binding = 1) readonly buffer tilemap
{
    uint8_t tiles[];
};

layout (set = 1, binding = 10) uniform sampler2D globalTextures[];

layout (location = 0) out vec4 fragColor;

const uint INVALID_TEXTURE_INDEX = 255;

void main()
{
    vec2 position = vec2(gl_FragCoord.x + eye.x * 10.0f, gl_FragCoord.y - eye.y * 10.0f); //TODO: standardized unit size
    ivec2 tilePos = ivec2(uint(position.x * tileSize.x), uint(position.y * tileSize.y));
    vec2 texcoord = fract(position * tileSize);

    uint index = tilePos.x + tilePos.y * width;

    if(position.x < 0 || position.y < 0 || tilePos.x >= width || tilePos.y >= height) { discard; }

#if DEBUG == 1
    if(texcoord.x < 0.01 || texcoord.y < 0.01 || texcoord.x > 0.99 || texcoord.y > 0.99) { fragColor = vec4(1.0, 0.0, 0.0, 1.0); return; }
#endif

    uint8_t tileType = tiles[index];

    if(tileType == INVALID_TEXTURE_INDEX) { discard; }

    uint16_t textureIndex = textureIndices[tileType];

    fragColor = texture(globalTextures[textureIndex], texcoord);
}